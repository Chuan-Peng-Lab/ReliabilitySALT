---
title: "0_Functions_Split_Half"
author: "yuki"
date: "2023-04-30"
output: html_document
---
# Split Half
These functions are packaged
library(splithalf)
## MC Split Half
```{r mcshrgener_st}
mcshrgener_st <- function(df.split, iteration) {
# Scientific notation
options(scipen = 999)

# MC seed
set.seed(123)

#convert data.frame to data.table
setDT(df.split)

# Stratify the data by Match and Identity
split_data <- split(df.split,list(df.split$Subject, df.split$Session,
                                  df.split$Matching, df.split$Identity))

# Initialize a vector to store the Pearson correlation coefficients
split_list <- vector("list", iteration)

  for (j in 1:iteration) {
  
    # Initialize empty lists to store the split-half data sets
    str_half_split_1 <- list()
    str_half_split_2 <- list()

    # Calculate the split-half reliability for each group
    str_half_split <- lapply(split_data, function(x) {
      
      # Remove rows with missing values 
      data <- x[complete.cases(x),]

      # Permute the rows of the data and split it into two halves
      permuted_data <- data[sample(nrow(data)),]
      half_split_1 <- permuted_data[1:floor(nrow(permuted_data)/2),]
      half_split_2 <- permuted_data[(floor(nrow(permuted_data)/2)+1):nrow(permuted_data),]

      # Get the minimum number of rows between the two data sets
      min_rows <- min(nrow(half_split_1), nrow(half_split_2))

      # Subset both data sets to use the same number of rows
      half_split_1 <- half_split_1[1:min_rows,]
      half_split_2 <- half_split_2[1:min_rows,]

      # Return the split-half data sets
      return(list(half_split_1, half_split_2))
      })

  # Combine the split-half data sets from all groups
  str_half_split_1 <- do.call(rbind, lapply(str_half_split, "[[", 1))
  str_half_split_2 <- do.call(rbind, lapply(str_half_split, "[[", 2))

  split_list[[j]] <- list(str_half_split_1, str_half_split_2)

}

return(split_list)
}

```

```{r mcshrgener_mt}
mcshrgener <- function(df.split, iteration, nc, sub, var1, var2, var3) {
  # Scientific notation
  options(scipen = 999)
  
  # Convert data.frame to data.table
  setDT(df.split)

  # Stratify the data by Matching and Identity
  split_data <- split(df.split, list(df.split[[sub]], df.split[[var1]], 
                                     df.split[[var2]], df.split[[var3]]))

  # Initialize a vector to store the Pearson correlation coefficients
  split_list <- vector("list", iteration)

  # Initialize the parallel backend
  registerDoParallel(nc)

  # declare j variable
  j <- 0
  
  # Run the for loop in parallel
  split_list <- foreach(j = 1:iteration, .combine = "c") %dopar% {
    set.seed(122+j)
    # Initialize empty lists to store the split-half data sets
    str_half_split_1 <- list()
    str_half_split_2 <- list()

    # Calculate the split-half reliability for each group
    str_half_split <- lapply(split_data, function(x) {

      # Remove rows with missing values
      data <- x[complete.cases(x),]

      # Permute the rows of the data and split it into two halves
      permuted_data <- data[sample(nrow(data)),]
      half_split_1 <- permuted_data[1:floor(nrow(permuted_data)/2),]
      half_split_2 <- permuted_data[(floor(nrow(permuted_data)/2)+1):nrow(permuted_data),]

      # Get the minimum number of rows between the two data sets
      min_rows <- min(nrow(half_split_1), nrow(half_split_2))

      # Subset both data sets to use the same number of rows
      half_split_1 <- half_split_1[1:min_rows,]
      half_split_2 <- half_split_2[1:min_rows,]

      # Return the split-half data sets
      return(list(half_split_1, half_split_2))
    })

    # Combine the split-half data sets from all groups
    str_half_split_1 <- do.call(rbind, lapply(str_half_split, "[[", 1))
    str_half_split_2 <- do.call(rbind, lapply(str_half_split, "[[", 2))

    # Return the split-half data sets
    return(list(str_half_split_1, str_half_split_2))
  }
  
  # Stop the parallel backend
  stopImplicitCluster()

  # Combine every two sublists into a single list and create a new list of length iteration
  combined_list <- vector("list", iteration)
  for (i in 1:iteration) {
    combined_list[[i]] <- list(split_list[[2*i-1]], split_list[[2*i]])
  }
  
  return(combined_list)
}

```

## Other Split Half
```{r Split Tool}
  split_tool <- function(df.split, method, sub, var1, var2, var3) {

  # Set the seed to fix the output value
  set.seed(123)

  # Scientific notation
  options(scipen = 999)

  # Stratify the data by Matching and Identity
  split_data <- split(df.split, list(df.split[[sub]], df.split[[var1]], 
                                     df.split[[var2]], df.split[[var3]]))

  # Initialize empty lists to store the split-half data sets
  str_half_split_1 <- list()
  str_half_split_2 <- list()

    # Calculate the split-half reliability for each group
    str_half_split <- lapply(split_data, function(x) {
      
      # Remove rows with missing values 
      data <- x[complete.cases(x),]

      
      if(method == "permuted") {
        # Permute the rows of the data and split it into two halves
        permuted_data <- data[sample(nrow(data)),]
        half_split_1 <- permuted_data[1:floor(nrow(permuted_data)/2),]
        half_split_2 <- permuted_data[(floor(nrow(permuted_data)/2)+1):nrow(permuted_data),]
      }
      else if(method == "fs") {
        # Split the data into two subsets using a first-second split
        half_split_1 <- data[1:floor(nrow(data)/2),]
        half_split_2 <- data[(floor(nrow(data)/2)+1):nrow(data),]  
      }
      else {
        # Create a vector of row indices
        row_indices <- seq(1, nrow(data))
        # Select the odd-numbered indices for one split-half group
        half_split_1 <- data[row_indices %% 2 == 1, ]
        # Select the even-numbered indices for the other split-half group
        half_split_2 <- data[row_indices %% 2 == 0, ]
      }
      
    # Get the minimum number of rows between the two data sets
    min_rows <- min(nrow(half_split_1), nrow(half_split_2))

    # Subset both data sets to use the same number of rows
    half_split_1 <- half_split_1[1:min_rows,]
    half_split_2 <- half_split_2[1:min_rows,]

    # Return the split-half data sets
    return(list(half_split_1, half_split_2))
      })

  # Combine the split-half data sets from all groups
  str_half_split_1 <- do.call(rbind, lapply(str_half_split, "[[", 1))
  str_half_split_2 <- do.call(rbind, lapply(str_half_split, "[[", 2))

  split_list <- list(str_half_split_1, str_half_split_2)
  
  return(split_list)
}
```

